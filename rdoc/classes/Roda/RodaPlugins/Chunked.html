<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Roda::RodaPlugins::Chunked</title>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='class' id='wrapper'>
<div class='header'>
<h1 class='name'><span class='type'>module</span>
Roda::RodaPlugins::Chunked
</h1>
<ol class='paths'>
<li>
<a href="../../../files/lib/roda/plugins/chunked_rb.html">lib/roda/plugins/chunked.rb</a>
</li>
</ol>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>The chunked plugin allows you to stream rendered views to clients. This can significantly improve performance of page rendering on the client, as it flushes the headers and top part of the layout template (generally containing references to the stylesheet and javascript assets) before rendering the content template.</p>

<p>This allows the client to fetch the assets while the template is still being rendered.  Additionally, this plugin makes it easy to defer executing code required to render the content template until after the top part of the layout has been flushed, so the client can fetch the assets while the application is still doing the necessary processing in order to render the content template, such as retrieving values from a database.</p>

<p>There are a couple disadvantages of streaming.  First is that the layout must be rendered before the content, so any state changes made in your content template will not affect the layout template.  Second, error handling is reduced, since if an error occurs while rendering a template, a successful response code has already been sent.</p>

<p>To use chunked encoding for a response, just call the chunked method instead of view:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">chunked</span>(<span class="ruby-value">:index</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>If you want to execute code after flushing the top part of the layout template, but before rendering the content template, pass a block to chunked:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">chunked</span>(<span class="ruby-value">:index</span>) <span class="ruby-keyword">do</span>
    <span class="ruby-comment"># expensive calculation here</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>You can also call delay manually with a block, and the execution of the block will be delayed until rendering the content template.  This is useful if you want to delay execution for all routes under a branch:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&#39;albums&#39;</span>, <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album_id</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">delay</span> <span class="ruby-keyword">do</span>
    <span class="ruby-ivar">@album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-identifier">album_id</span>]
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-string">&#39;info&#39;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">chunked</span>(<span class="ruby-value">:info</span>)
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-string">&#39;tracks&#39;</span> <span class="ruby-keyword">do</span>
    <span class="ruby-identifier">chunked</span>(<span class="ruby-value">:tracks</span>)
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>If you want to chunk all responses, pass the :chunk_by_default option when loading the plugin:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:chunked</span>, <span class="ruby-value">chunk_by_default:</span> <span class="ruby-keyword">true</span>
</pre>

<p>then you can just use the normal view method:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">view</span>(<span class="ruby-value">:index</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>and it will chunk the response.  Note that you still need to call chunked if you want to pass a block of code to be executed after flushing the layout and before rendering the content template. Also, before you enable chunking by default, you need to make sure that none of your content templates make state changes that affect the layout template. Additionally, make sure nowhere in your app are you doing any processing after the call to view.</p>

<p>If you use :chunk_by_default, but want to turn off chunking for a view, call no_chunk!:</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">no_chunk!</span>
  <span class="ruby-identifier">view</span>(<span class="ruby-value">:index</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>Inside your layout or content templates, you can call the flush method to flush the current result of the template to the user, useful for streaming large datasets.</p>

<pre>&lt;% (1..100).each do |i| %&gt;
  &lt;%= i %&gt;
  &lt;% sleep 0.1 %&gt;
  &lt;% flush %&gt;
&lt;% end %&gt;</pre>

<p>Note that you should not call flush from inside subtemplates of the content or layout templates, unless you are also calling flush directly before rendering the subtemplate, and also directly injecting the subtemplate into the current template without modification.  So if you are using the above template code in a subtemplate, in your content template you should do:</p>

<pre>&lt;% flush %&gt;&lt;%= render(:subtemplate) %&gt;</pre>

<p>If you want to use chunked encoding when rendering a template, but donâ€™t want to use a layout, pass the <code>layout: false</code> option to chunked.</p>

<pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>
  <span class="ruby-identifier">chunked</span>(<span class="ruby-value">:index</span>, <span class="ruby-value">layout:</span> <span class="ruby-keyword">false</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>In order to handle errors in chunked responses, you can override the handle_chunk_error method:</p>

<pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">handle_chunk_error</span>(<span class="ruby-identifier">e</span>)
  <span class="ruby-identifier">env</span>[<span class="ruby-string">&#39;rack.logger&#39;</span>].<span class="ruby-identifier">error</span>(<span class="ruby-identifier">e</span>)
<span class="ruby-keyword">end</span>
</pre>

<p>It is possible to set @_out_buf to an error notification and call flush to output the message to the client inside handle_chunk_error.</p>

<p>In order for chunking to work, you must make sure that no proxies between the application and the client buffer responses.</p>

<p>If you are using nginx and have it set to buffer proxy responses by default, you can turn this off on a per response basis using the X-Accel-Buffering header.  To set this header or similar headers for all chunked responses, pass a :headers option when loading the plugin:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:chunked</span>, <span class="ruby-value">headers:</span> {<span class="ruby-string">&#39;X-Accel-Buffering&#39;</span><span class="ruby-operator">=&gt;</span><span class="ruby-string">&#39;no&#39;</span>}
</pre>

<p>By default, this plugin does not use Transfer-Encoding: chunked, it only returns a body that will stream the response in chunks.  If you would like to force the use of Transfer-Encoding: chunked, you can use the :force_chunked_encoding plugin option.  If using the :force_chunked_encoding plugin option, chunking will only be used for HTTP/1.1 requests since Transfer-Encoding: chunked is only supported in HTTP/1.1 (non-HTTP/1.1 requests will have behavior similar to calling no_chunk!).</p>

<p>The chunked plugin requires the render plugin, and only works for template engines that store their template output variable in @_out_buf.  Also, it only works if the content template is directly injected into the layout template without modification.</p>

<p>If using the chunked plugin with the flash plugin, make sure you call the flash method early in your route block.  If the flash method is not called until template rendering, the flash may not be rotated.</p>
</div>
<div id='method-list'>
<h2>Methods</h2>
<h3>Public Class</h3>
<ol>
<li><a href="#method-c-configure">configure</a></li>
<li><a href="#method-c-load_dependencies">load_dependencies</a></li>
</ol>
</div>
<div id='context'>
</div>
<div id='class-list'>
<h2>Classes and Modules</h2>
<ol>
<li><a href="Chunked/InstanceMethods.html">Roda::RodaPlugins::Chunked::InstanceMethods</a></li>
<li><a href="Chunked/Body.html">Roda::RodaPlugins::Chunked::Body</a></li>
<li><a href="Chunked/StreamBody.html">Roda::RodaPlugins::Chunked::StreamBody</a></li>
</ol>
</div>
<div id='section'>
<div id='methods'>
<h2>Public Class methods</h2>
<div class='method public-class' id='method-method-c-configure'>
<a name='method-c-configure'></a>
<div class='synopsis'>
<span class='name'>configure</span><span class='arguments'>(app, opts=OPTS)</span>

</div>
<div class='description'>

<p>Set plugin specific options.  Options:</p>
<table class="rdoc-list note-list"><tbody><tr><td class='label'>:chunk_by_default </td><td>
<p>chunk all calls to view by default</p>
</td></tr><tr><td class='label'>:headers </td><td>
<p>Set default additional headers to use when calling view</p>
</td></tr></tbody></table>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-c-configure-source&#39;); return false'>
[show source]
</a>
<pre id='method-c-configure-source'>    <span class="ruby-comment"># File lib/roda/plugins/chunked.rb</span>
<span class="line-num">159</span> <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">configure</span>(<span class="ruby-identifier">app</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)
<span class="line-num">160</span>   <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:chunk_by_default</span>] = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:chunk_by_default</span>]
<span class="line-num">161</span>   <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:force_chunked_encoding</span>] = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:force_chunked_encoding</span>]
<span class="line-num">162</span>   <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:headers</span>]
<span class="line-num">163</span>     <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:chunk_headers</span>] = (<span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:chunk_headers</span>] <span class="ruby-operator">||</span> {}).<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:headers</span>]).<span class="ruby-identifier">freeze</span>
<span class="line-num">164</span>   <span class="ruby-keyword">end</span>
<span class="line-num">165</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
<div class='method public-class' id='method-method-c-load_dependencies'>
<a name='method-c-load_dependencies'></a>
<div class='synopsis'>
<span class='name'>load_dependencies</span><span class='arguments'>(app, opts=OPTS)</span>

</div>
<div class='description'>

<p>Depend on the render plugin</p>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-c-load_dependencies-source&#39;); return false'>
[show source]
</a>
<pre id='method-c-load_dependencies-source'>    <span class="ruby-comment"># File lib/roda/plugins/chunked.rb</span>
<span class="line-num">152</span> <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">load_dependencies</span>(<span class="ruby-identifier">app</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">OPTS</span>)
<span class="line-num">153</span>   <span class="ruby-identifier">app</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:render</span>
<span class="line-num">154</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
</div>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna"><strong>Hanna</strong> RDoc template</a>
</div>
</body>
</html>
