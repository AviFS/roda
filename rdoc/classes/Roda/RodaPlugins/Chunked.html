<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>Roda::RodaPlugins::Chunked</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      function popupCode(url) {
        window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
      }
      
      function toggleCode(id) {
        var code = document.getElementById(id)
      
        code.style.display = code.style.display != 'block' ? 'block' : 'none'
        return true
      }
      
      // Make codeblocks hidden by default
      document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>module</span>
          Roda::RodaPlugins::Chunked
        </h1>
        <ol class='paths'>
          <li>
            <a href="../../../files/lib/roda/plugins/chunked_rb.html">lib/roda/plugins/chunked.rb</a>
          </li>
        </ol>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p>The chunked plugin allows you to stream responses to clients using
            Transfer-Encoding: chunked.  This can significantly improve performance of
            page rendering on the client, as it flushes the headers and top part of the
            layout template (generally containing references to the stylesheet and
            javascript assets) before rendering the content template.</p>
            
            <p>This allows the client to fetch the assets while the template is still
            being rendered.  Additionally, this plugin makes it easy to defer executing
            code required to render the content template until after the top part of
            the layout has been flushed, so the client can fetch the assets while the
            application is still doing the necessary processing in order to render the
            content template, such as retrieving values from a database.</p>
            
            <p>There are a couple disadvantages of streaming using chunked encoding. First
            is that the layout must be rendered before the content, so any state 
            changes made in your content template will not affect the layout template.
            Second, error handling is reduced, since if an error occurs while rendering
            a template, a successful response code has already been sent.</p>
            
            <p>To use chunked encoding for a response, just call the chunked method
            instead of view:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">chunked</span>(:<span class="ruby-identifier">index</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you want to execute code after flushing the top part of the layout
            template, but before rendering the content template, pass a block to
            chunked:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">chunked</span>(:<span class="ruby-identifier">index</span>) <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-comment"># expensive calculation here</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You can also call delay manually with a block, and the execution of the
            block will be delayed until rendering the content template.  This is useful
            if you want to delay execution for all routes under a branch:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">on</span> <span class="ruby-string">&#39;albums&#39;</span>, <span class="ruby-constant">Integer</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">album_id</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">delay</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-ivar">@album</span> = <span class="ruby-constant">Album</span>[<span class="ruby-identifier">album_id</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-string">&#39;info&#39;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">chunked</span>(:<span class="ruby-identifier">info</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-string">&#39;tracks&#39;</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">chunked</span>(:<span class="ruby-identifier">tracks</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you want to chunk all responses, pass the :chunk_by_default option when
            loading the plugin:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">chunked</span>, :<span class="ruby-identifier">chunk_by_default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword">true</span></pre>
            
            <p>then you can just use the normal view method:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">view</span>(:<span class="ruby-identifier">index</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>and it will chunk the response.  Note that you still need to call chunked
            if you want to pass a block of code to be executed after flushing the
            layout and before rendering the content template. Also, before you enable
            chunking by default, you need to make sure that none of your content
            templates make state changes that affect the layout template. Additionally,
            make sure nowhere in your app are you doing any processing after the call
            to view.</p>
            
            <p>If you use :chunk_by_default, but want to turn off chunking for a view,
            call no_chunk!:</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">no_chunk!</span>&#x000A;  <span class="ruby-identifier">view</span>(:<span class="ruby-identifier">index</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>Inside your layout or content templates, you can call the flush method to
            flush the current result of the template to the user, useful for streaming
            large datasets.</p>
            
            <pre>&lt;% (1..100).each do |i| %&gt;&#x000A;  &lt;%= i %&gt;&#x000A;  &lt;% sleep 0.1 %&gt;&#x000A;  &lt;% flush %&gt;&#x000A;&lt;% end %&gt;</pre>
            
            <p>Note that you should not call flush from inside subtemplates of the content
            or layout templates, unless you are also calling flush directly before
            rendering the subtemplate, and also directly injecting the subtemplate into
            the current template without modification.  So if you are using the above
            template code in a subtemplate, in your content template you should do:</p>
            
            <pre>&lt;% flush %&gt;&lt;%= render(:subtemplate) %&gt;</pre>
            
            <p>If you want to use chunked encoding when rendering a template, but
            don&#39;t want to use a layout, pass the :layout=&gt;false option to
            chunked.</p>
            
            <pre class="ruby"><span class="ruby-identifier">r</span>.<span class="ruby-identifier">root</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">chunked</span>(:<span class="ruby-identifier">index</span>, :<span class="ruby-identifier">layout=</span><span class="ruby-operator">&gt;</span><span class="ruby-keyword">false</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>In order to handle errors in chunked responses, you can override the
            handle_chunk_error method:</p>
            
            <pre class="ruby"><span class="ruby-keyword">def</span> <span class="ruby-identifier">handle_chunk_error</span>(<span class="ruby-identifier">e</span>)&#x000A;  <span class="ruby-identifier">env</span>[<span class="ruby-string">&#39;rack.logger&#39;</span>].<span class="ruby-identifier">error</span>(<span class="ruby-identifier">e</span>)&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>It is possible to set @_out_buf to an error notification and call flush to
            output the message to the client inside handle_chunk_error.</p>
            
            <p>In order for chunking to work, you must make sure that no proxies between
            the application and the client buffer responses.  Also, this plugin only
            works for HTTP/1.1 requests since Transfer-Encoding: chunked is not
            supported in HTTP/1.0.  If an HTTP/1.0 request is submitted, this plugin
            will automatically fallback to the normal template rendering. Note that
            some proxies including nginx default to HTTP/1.0 even if the client
            supports HTTP/1.1.  For nginx, set the proxy_http_version to 1.1.</p>
            
            <p>If you are using nginx and have it set to buffer proxy responses by
            default, you can turn this off on a per response basis using the
            X-Accel-Buffering header.  To set this header or similar headers for all
            chunked responses, pass a :headers option when loading the plugin:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">chunked</span>, :<span class="ruby-identifier">headers=</span><span class="ruby-operator">&gt;</span>{<span class="ruby-string">&#39;X-Accel-Buffering&#39;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-string">&#39;no&#39;</span>}</pre>
            
            <p>The chunked plugin requires the render plugin, and only works for template
            engines that store their template output variable in @_out_buf.  Also, it
            only works if the content template is directly injected into the layout
            template without modification.</p>
            
            <p>If using the chunked plugin with the flash plugin, make sure you call the
            flash method early in your route block.  If the flash method is not called
            until template rendering, the flash may not be rotated.</p>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>Public Class</h3>
            <ol>
              <li><a href="#method-c-configure">configure</a></li>
              <li><a href="#method-c-load_dependencies">load_dependencies</a></li>
            </ol>
          </div>
          <div id='context'>
          </div>
          <div id='class-list'>
            <h2>Classes and Modules</h2>
            <ol>
              <li><a href="Chunked/InstanceMethods.html">Roda::RodaPlugins::Chunked::InstanceMethods</a></li>
              <li><a href="Chunked/Body.html">Roda::RodaPlugins::Chunked::Body</a></li>
            </ol>
          </div>
          <div id='section'>
            <div id='constants-list'>
              <h2>Constants</h2>
              <div class='name-list'>
                <table summary='Constants'>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>CHUNKED</td>
                    <td>=</td>
                    <td class='context-item-value'>'chunked'.freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>HTTP11</td>
                    <td>=</td>
                    <td class='context-item-value'>"HTTP/1.1".freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>HTTP_VERSION</td>
                    <td>=</td>
                    <td class='context-item-value'>'HTTP_VERSION'.freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>OPTS</td>
                    <td>=</td>
                    <td class='context-item-value'>{}.freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>TRANSFER_ENCODING</td>
                    <td>=</td>
                    <td class='context-item-value'>'Transfer-Encoding'.freeze</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                </table>
              </div>
            </div>
            <div id='methods'>
              <h2>Public Class methods</h2>
              <div class='method public-class' id='method-method-c-configure'>
                <a name='method-c-configure'></a>
                <div class='synopsis'>
                  <span class='name'>configure</span>
                  <span class='arguments'>(app, opts=RodaPlugins::OPTS)</span>
                </div>
                <div class='description'>
                  
                  <p>Set plugin specific options.  Options:</p>
                  <table class="rdoc-list note-list"><tbody><tr><td class='label'>:chunk_by_default </td><td>
                  <p>chunk all calls to view by default</p>
                  </td></tr><tr><td class='label'>:headers </td><td>
                  <p>Set default additional headers to use when calling view</p>
                  </td></tr></tbody></table>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-configure-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-configure-source'><span class="ruby-comment"># File lib/roda/plugins/chunked.rb, line 166</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">configure</span>(<span class="ruby-identifier">app</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">RodaPlugins</span><span class="ruby-operator">::</span><span class="ruby-constant">OPTS</span>)&#x000A;  <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:chunk_by_default</span>] = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:chunk_by_default</span>]&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:headers</span>]&#x000A;    <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:chunk_headers</span>] = (<span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:chunk_headers</span>] <span class="ruby-operator">||</span> {}).<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:headers</span>]).<span class="ruby-identifier">freeze</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-class' id='method-method-c-load_dependencies'>
                <a name='method-c-load_dependencies'></a>
                <div class='synopsis'>
                  <span class='name'>load_dependencies</span>
                  <span class='arguments'>(app, opts=RodaPlugins::OPTS)</span>
                </div>
                <div class='description'>
                  
                  <p>Depend on the render plugin</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-load_dependencies-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-load_dependencies-source'><span class="ruby-comment"># File lib/roda/plugins/chunked.rb, line 159</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">load_dependencies</span>(<span class="ruby-identifier">app</span>, <span class="ruby-identifier">opts</span>=<span class="ruby-constant">RodaPlugins</span><span class="ruby-operator">::</span><span class="ruby-constant">OPTS</span>)&#x000A;  <span class="ruby-identifier">app</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:render</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
    </div>
  </body>
</html>
