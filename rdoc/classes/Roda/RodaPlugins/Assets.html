<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
  <head>
    <title>Roda::RodaPlugins::Assets</title>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
    <script type='text/javascript'>
      function popupCode(url) {
        window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
      }
      
      function toggleCode(id) {
        var code = document.getElementById(id)
      
        code.style.display = code.style.display != 'block' ? 'block' : 'none'
        return true
      }
      
      // Make codeblocks hidden by default
      document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
    </script>
  </head>
  <body class='page'>
    <div class='class' id='wrapper'>
      <div class='header'>
        <h1 class='name'>
          <span class='type'>module</span>
          Roda::RodaPlugins::Assets
        </h1>
        <ol class='paths'>
          <li>
            <a href="../../../files/lib/roda/plugins/assets_rb.html">lib/roda/plugins/assets.rb</a>
          </li>
        </ol>
      </div>
      <div id='content'>
        <div id='text'>
          <div id='description'>
            
            <p>The assets plugin adds support for rendering your CSS and javascript asset
            files on the fly in development, and compiling them to a single, compressed
            file in production.</p>
            
            <p>This uses the render plugin for rendering the assets, and the render plugin
            uses tilt internally, so you can use any template engine supported by tilt
            for your assets.  Tilt ships with support for the following asset template
            engines, assuming the necessary libraries are installed:</p>
            <table class="rdoc-list note-list"><tbody><tr><td class='label'>css </td><td>
            <p>Less, Sass, Scss</p>
            </td></tr><tr><td class='label'>js </td><td>
            <p>CoffeeScript</p>
            </td></tr></tbody></table>
            
            <p>You can also use opal as a javascript template engine, assuming it is
            installed.</p>
            
            <h2 id="module-Roda::RodaPlugins::Assets-label-Usage">Usage<span><a href="#module-Roda::RodaPlugins::Assets-label-Usage">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>When loading the plugin, use the :css and :js options to set the source
            file(s) to use for CSS and javascript assets:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">assets</span>, <span class="ruby-identifier">css</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;some_file.scss&#39;</span>, <span class="ruby-identifier">js</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;some_file.coffee&#39;</span></pre>
            
            <p>This will look for the following files:</p>
            
            <pre class="ruby"><span class="ruby-identifier">assets</span><span class="ruby-operator">/</span><span class="ruby-identifier">css</span><span class="ruby-operator">/</span><span class="ruby-identifier">some_file</span>.<span class="ruby-identifier">scss</span>&#x000A;<span class="ruby-identifier">assets</span><span class="ruby-operator">/</span><span class="ruby-identifier">js</span><span class="ruby-operator">/</span><span class="ruby-identifier">some_file</span>.<span class="ruby-identifier">coffee</span></pre>
            
            <p>The values for the :css and :js options can be arrays to load multiple
            files. If you want to change the paths where asset files are stored, see
            the Options section below.</p>
            
            <h3 id="module-Roda::RodaPlugins::Assets-label-Serving">Serving<span><a href="#module-Roda::RodaPlugins::Assets-label-Serving">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>In your routes, call the <code>r.assets</code> method to add a route to
            your assets, which will make your app serve the rendered assets:</p>
            
            <pre class="ruby"><span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">assets</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>You should generally call <code>r.assets</code> inside the route block
            itself, and not under any branches of the routing tree.</p>
            
            <h3 id="module-Roda::RodaPlugins::Assets-label-Views">Views<span><a href="#module-Roda::RodaPlugins::Assets-label-Views">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>In your layout view, use the assets method to add links to your CSS and
            javascript assets:</p>
            
            <pre>&lt;%= assets(:css) %&gt;&#x000A;&lt;%= assets(:js) %&gt;</pre>
            
            <p>You can add attributes to the tags by using an options hash:</p>
            
            <pre>&lt;%= assets(:css, media: &#39;print&#39;) %&gt;</pre>
            
            <p>The assets method will respect the application&#39;s
            <code>:add_script_name</code> option, if it set it will automatically
            prefix the path with the <code>SCRIPT_NAME</code> for the request.</p>
            
            <h2 id="module-Roda::RodaPlugins::Assets-label-Asset+Paths">Asset Paths<span><a href="#module-Roda::RodaPlugins::Assets-label-Asset+Paths">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>If you just want the paths rather than the full tags, you can use
            assets_paths instead. This will return an array of the sources that the
            assets function would have put into tags:</p>
            
            <pre class="ruby"><span class="ruby-identifier">assets_paths</span>(:<span class="ruby-identifier">css</span>)&#x000A;<span class="ruby-comment"># =&gt; [&quot;/assets/css/foo.css&quot;, &quot;/assets/css/app.css&quot;]</span></pre>
            
            <p>If compilation is turned on, it will return the path to the compiled asset:</p>
            
            <pre class="ruby"><span class="ruby-identifier">assets_paths</span>(:<span class="ruby-identifier">css</span>)&#x000A;<span class="ruby-comment"># =&gt; [&quot;/assets/app.5e7b06baa1a514d8473b0eca514b806c201073b9.css&quot;]</span></pre>
            
            <h2 id="module-Roda::RodaPlugins::Assets-label-Asset+Groups">Asset Groups<span><a href="#module-Roda::RodaPlugins::Assets-label-Asset+Groups">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The asset plugin supports groups for the cases where you have different
            css/js files for your front end and back end.  To use asset groups, you
            pass a hash for the :css and/or :js options:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">assets</span>, <span class="ruby-identifier">css</span><span class="ruby-operator">:</span> {<span class="ruby-identifier">frontend</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;some_frontend_file.scss&#39;</span>,&#x000A;                      <span class="ruby-identifier">backend</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;some_backend_file.scss&#39;</span>}</pre>
            
            <p>This expects the following directory structure for your assets:</p>
            
            <pre class="ruby"><span class="ruby-identifier">assets</span><span class="ruby-operator">/</span><span class="ruby-identifier">css</span><span class="ruby-operator">/</span><span class="ruby-identifier">frontend</span><span class="ruby-operator">/</span><span class="ruby-identifier">some_frontend_file</span>.<span class="ruby-identifier">scss</span>&#x000A;<span class="ruby-identifier">assets</span><span class="ruby-operator">/</span><span class="ruby-identifier">css</span><span class="ruby-operator">/</span><span class="ruby-identifier">backend</span><span class="ruby-operator">/</span><span class="ruby-identifier">some_backend_file</span>.<span class="ruby-identifier">scss</span></pre>
            
            <p>If you do not want to force that directory structure when using asset
            groups, you can use the <code>group_subdirs: false</code> option.</p>
            
            <p>In your view code use an array argument in your call to assets:</p>
            
            <pre>&lt;%= assets([:css, :frontend]) %&gt;</pre>
            
            <h3 id="module-Roda::RodaPlugins::Assets-label-Nesting">Nesting<span><a href="#module-Roda::RodaPlugins::Assets-label-Nesting">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>Asset groups also support nesting, though that should only be needed in
            fairly large applications.  You can use a nested hash when loading the
            plugin:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">assets</span>,&#x000A;  <span class="ruby-identifier">css</span><span class="ruby-operator">:</span> {<span class="ruby-identifier">frontend</span><span class="ruby-operator">:</span> {<span class="ruby-identifier">dashboard</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;some_frontend_file.scss&#39;</span>}}</pre>
            
            <p>and an extra entry per nesting level when creating the tags.</p>
            
            <pre>&lt;%= assets([:css, :frontend, :dashboard]) %&gt;</pre>
            
            <h2 id="module-Roda::RodaPlugins::Assets-label-Caching"><a href="Caching.html">Caching</a><span><a href="#module-Roda::RodaPlugins::Assets-label-Caching">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The assets plugin uses the caching plugin internally, and will set the
            Last-Modified header to the modified timestamp of the asset source file
            when rendering the asset.</p>
            
            <p>If you have assets that include other asset files, such as using @import in
            a sass file, you need to specify the dependencies for your assets so that
            the assets plugin will correctly pick up changes.  You can do this using
            the :dependencies option to the plugin, which takes a hash where the keys
            are paths to asset files, and values are arrays of paths to dependencies of
            those asset files:</p>
            
            <pre class="ruby"><span class="ruby-identifier">app</span>.<span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">assets</span>,&#x000A;  <span class="ruby-identifier">dependencies</span><span class="ruby-operator">:</span> {<span class="ruby-string">&#39;assets/css/bootstrap.scss&#39;</span>=<span class="ruby-operator">&gt;</span><span class="ruby-constant">Dir</span>[<span class="ruby-string">&#39;assets/css/bootstrap/&#39;</span> <span class="ruby-string">&#39;**/*.scss&#39;</span>]}</pre>
            
            <h2 id="module-Roda::RodaPlugins::Assets-label-Asset+Compilation">Asset Compilation<span><a href="#module-Roda::RodaPlugins::Assets-label-Asset+Compilation">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>In production, you are generally going to want to compile your assets into
            a single file, with you can do by calling compile_assets after loading the
            plugin:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">assets</span>, <span class="ruby-identifier">css</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;some_file.scss&#39;</span>, <span class="ruby-identifier">js</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;some_file.coffee&#39;</span>&#x000A;<span class="ruby-identifier">compile_assets</span></pre>
            
            <p>After calling compile_assets, calls to assets in your views will default to
            a using a single link each to your CSS and javascript compiled asset files.
            By default the compiled files are written to the public directory, so that
            they can be served by the webserver.</p>
            
            <h3 id="module-Roda::RodaPlugins::Assets-label-Asset+Compression">Asset Compression<span><a href="#module-Roda::RodaPlugins::Assets-label-Asset+Compression">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>If you have the yuicompressor gem installed and working, it will be used
            automatically to compress your javascript and css assets.  For javascript
            assets, if yuicompressor is not available, the plugin will check for
            closure_compiler, uglifier, and minjs and use the first one that works. If
            no compressors are available, the assets will just be concatenated together
            and not compressed during compilation.  You can use the :css_compressor and
            :js_compressor options to specify the compressor to use.</p>
            
            <h3 id="module-Roda::RodaPlugins::Assets-label-With+Asset+Groups">With Asset Groups<span><a href="#module-Roda::RodaPlugins::Assets-label-With+Asset+Groups">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>When using asset groups, a separate compiled file will be produced per
            asset group.</p>
            
            <h3 id="module-Roda::RodaPlugins::Assets-label-Unique+Asset+Names">Unique Asset Names<span><a href="#module-Roda::RodaPlugins::Assets-label-Unique+Asset+Names">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>When compiling assets, a unique name is given to each asset file, using the
            a SHA1 hash of the content of the file.  This is done so that clients do
            not attempt to use cached versions of the assets if the asset has changed.</p>
            
            <h3 id="module-Roda::RodaPlugins::Assets-label-Serving">Serving<span><a href="#module-Roda::RodaPlugins::Assets-label-Serving">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>When compiling assets, <code>r.assets</code> will serve the compiled asset
            files.  However, it is recommended to have the main webserver (e.g. nginx)
            serve the compiled files, instead of relying on the application.</p>
            
            <p>Assuming you are using compiled assets in production mode that are served
            by the webserver, you can remove the serving of them by the application:</p>
            
            <pre class="ruby"><span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>&#x000A;  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">assets</span> <span class="ruby-keyword">unless</span> <span class="ruby-constant">ENV</span>[<span class="ruby-string">&#39;RACK_ENV&#39;</span>] <span class="ruby-operator">==</span> <span class="ruby-string">&#39;production&#39;</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <p>If you do have the application serve the compiled assets, it will use the
            Last-Modified header to make sure that clients do not redownload compiled
            assets that haven&#39;t changed.</p>
            
            <h3 id="module-Roda::RodaPlugins::Assets-label-Asset+Precompilation">Asset Precompilation<span><a href="#module-Roda::RodaPlugins::Assets-label-Asset+Precompilation">&para;</a> <a href="#top">&uarr;</a></span></h3>
            
            <p>If you want to precompile your assets, so they do not need to be compiled
            every time you boot the application, you can provide a :precompiled option
            when loading the plugin.  The value of this option should be the filename
            where the compiled asset metadata is stored.</p>
            
            <p>If the compiled asset metadata file does not exist when the assets plugin
            is loaded, the plugin will run in non-compiled mode.  However, when you
            call compile_assets, it will write the compiled asset metadata file after
            compiling the assets.</p>
            
            <p>If the compiled asset metadata file already exists when the assets plugin
            is loaded, the plugin will read the file to get the compiled asset
            metadata, and it will run in compiled mode, assuming that the compiled
            asset files already exist.</p>
            
            <h4 id="module-Roda::RodaPlugins::Assets-label-On+Heroku">On Heroku<span><a href="#module-Roda::RodaPlugins::Assets-label-On+Heroku">&para;</a> <a href="#top">&uarr;</a></span></h4>
            
            <p>Heroku supports precompiling the assets when using <a
            href="../../Roda.html">Roda</a>.  You just need to add an assets:precompile
            task, similar to this:</p>
            
            <pre class="ruby"><span class="ruby-identifier">namespace</span> :<span class="ruby-identifier">assets</span> <span class="ruby-keyword">do</span>&#x000A;  <span class="ruby-identifier">desc</span> <span class="ruby-string">&quot;Precompile the assets&quot;</span>&#x000A;  <span class="ruby-identifier">task</span> :<span class="ruby-identifier">precompile</span> <span class="ruby-keyword">do</span>&#x000A;    <span class="ruby-identifier">require</span> <span class="ruby-string">&#39;./app&#39;</span>&#x000A;    <span class="ruby-constant">App</span>.<span class="ruby-identifier">compile_assets</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;<span class="ruby-keyword">end</span></pre>
            
            <h2 id="module-Roda::RodaPlugins::Assets-label-Postprocessing">Postprocessing<span><a href="#module-Roda::RodaPlugins::Assets-label-Postprocessing">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>If you pass a callable object to the :postprocessor option, it will be
            called before an asset is served. If the assets are to be compiled, the
            object will be called at compilation time.</p>
            
            <p>It is passed three arguments; the name of the asset file, the type of the
            asset file (which is a symbol, either :css or :js), and the asset contents.</p>
            
            <p>It should return the new content for the asset.</p>
            
            <p>You can use this to call Autoprefixer on your CSS:</p>
            
            <pre class="ruby"><span class="ruby-identifier">plugin</span> :<span class="ruby-identifier">assets</span>, {&#x000A;  <span class="ruby-identifier">css</span><span class="ruby-operator">:</span> [ <span class="ruby-string">&#39;style.scss&#39;</span> ],&#x000A;  <span class="ruby-identifier">postprocessor</span><span class="ruby-operator">:</span> <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">file</span>, <span class="ruby-identifier">type</span>, <span class="ruby-identifier">content</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">type</span> <span class="ruby-operator">==</span> :<span class="ruby-identifier">css</span> <span class="ruby-operator">?</span> <span class="ruby-constant">AutoprefixerRails</span>.<span class="ruby-identifier">process</span>(<span class="ruby-identifier">content</span>).<span class="ruby-identifier">css</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">content</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;}</pre>
            
            <h2 id="module-Roda::RodaPlugins::Assets-label-External+Assets-2FAssets+from+Gems">External Assets/Assets from Gems<span><a href="#module-Roda::RodaPlugins::Assets-label-External+Assets-2FAssets+from+Gems">&para;</a> <a href="#top">&uarr;</a></span></h2>
            
            <p>The assets plugin only supports loading assets files underneath the assets
            path.  You cannot pass an absolute path to an asset file and have it work. 
            If you would like to reference asset files that are outside the assets
            path, you have the following options:</p>
            <ul><li>
            <p>Copy, hard link, or symlink the external assets files into the assets path.</p>
            </li><li>
            <p>Use tilt-indirect or another method of indirection (such as an erb template
            that loads the external asset file) so that a file inside the assets path
            can reference files outside the assets path.</p>
            </li></ul>
            
            <h2 id="module-Roda::RodaPlugins::Assets-label-Plugin+Options">Plugin Options<span><a href="#module-Roda::RodaPlugins::Assets-label-Plugin+Options">&para;</a> <a href="#top">&uarr;</a></span></h2>
            <table class="rdoc-list note-list"><tbody><tr><td class='label'>:add_suffix </td><td>
            <p>Whether to append a .css or .js extension to asset routes in non-compiled
            mode (default: false)</p>
            </td></tr><tr><td class='label'>:compiled_asset_host </td><td>
            <p>The asset host to use for compiled assets.  Should include the protocol as
            well as the host (e.g. “<a
            href="https://cdn.example.com">cdn.example.com</a>”, “//cdn.example.com”)</p>
            </td></tr><tr><td class='label'>:compiled_css_dir </td><td>
            <p>Directory name in which to store the compiled css file, inside
            :compiled_path (default: nil)</p>
            </td></tr><tr><td class='label'>:compiled_css_route </td><td>
            <p>Route under :prefix for compiled css assets (default: :compiled_css_dir)</p>
            </td></tr><tr><td class='label'>:compiled_js_dir </td><td>
            <p>Directory name in which to store the compiled javascript file, inside
            :compiled_path (default: nil)</p>
            </td></tr><tr><td class='label'>:compiled_js_route </td><td>
            <p>Route under :prefix for compiled javscript assets (default:
            :compiled_js_dir)</p>
            </td></tr><tr><td class='label'>:compiled_name </td><td>
            <p>Compiled file name prefix (default: &#39;app&#39;)</p>
            </td></tr><tr><td class='label'>:compiled_path</td><td>
            <p><a href="Path.html">Path</a> inside public folder in which compiled files
            are stored (default: :prefix)</p>
            </td></tr><tr><td class='label'>:concat_only </td><td>
            <p>Whether to just concatenate instead of concatenating and compressing files
            (default: false)</p>
            </td></tr><tr><td class='label'>:css_compressor </td><td>
            <p>Compressor to use for compressing CSS, either :yui, :none, or nil (the
            default, which will try :yui if available, but not fail if it is not
            available)</p>
            </td></tr><tr><td class='label'>:css_dir </td><td>
            <p>Directory name containing your css source, inside :path (default:
            &#39;css&#39;)</p>
            </td></tr><tr><td class='label'>:css_headers </td><td>
            <p>A hash of additional headers for your rendered css files</p>
            </td></tr><tr><td class='label'>:css_opts </td><td>
            <p>Template options to pass to the render plugin (via :template_opts) when
            rendering css assets</p>
            </td></tr><tr><td class='label'>:css_route </td><td>
            <p>Route under :prefix for css assets (default: :css_dir)</p>
            </td></tr><tr><td class='label'>:dependencies </td><td>
            <p>A hash of dependencies for your asset files.  Keys should be paths to asset
            files, values should be arrays of paths your asset files depends on.  This
            is used to detect changes in your asset files.</p>
            </td></tr><tr><td class='label'>:group_subdirs </td><td>
            <p>Whether a hash used in :css and :js options requires the assets for the
            related group are contained in a subdirectory with the same name (default:
            true)</p>
            </td></tr><tr><td class='label'>:gzip </td><td>
            <p>Store gzipped compiled assets files, and serve those to clients who accept
            gzip encoding.</p>
            </td></tr><tr><td class='label'>:headers </td><td>
            <p>A hash of additional headers for both js and css rendered files</p>
            </td></tr><tr><td class='label'>:js_compressor </td><td>
            <p>Compressor to use for compressing javascript, either :yui, :closure,
            :uglifier, :minjs, :none, or nil (the default, which will try :yui,
            :closure, :uglifier, then :minjs, but not fail if any of them is not
            available)</p>
            </td></tr><tr><td class='label'>:js_dir </td><td>
            <p>Directory name containing your javascript source, inside :path (default:
            &#39;js&#39;)</p>
            </td></tr><tr><td class='label'>:js_headers </td><td>
            <p>A hash of additional headers for your rendered javascript files</p>
            </td></tr><tr><td class='label'>:js_opts </td><td>
            <p>Template options to pass to the render plugin (via :template_opts) when
            rendering javascript assets</p>
            </td></tr><tr><td class='label'>:js_route </td><td>
            <p>Route under :prefix for javascript assets (default: :js_dir)</p>
            </td></tr><tr><td class='label'>:path </td><td>
            <p><a href="Path.html">Path</a> to your asset source directory (default:
            &#39;assets&#39;).   Relative paths will be considered relative to the
            application&#39;s :root option.</p>
            </td></tr><tr><td class='label'>:postprocessor </td><td>
            <p>A block which should accept three arguments (asset name, asset type,
            content). This block can be used to hook into the asset system and make
            your own modifications before the asset is served. If the asset is to be
            compiled, the block is called at compile time.</p>
            </td></tr><tr><td class='label'>:prefix </td><td>
            <p>Prefix for assets path in your URL/routes (default: &#39;assets&#39;)</p>
            </td></tr><tr><td class='label'>:precompiled </td><td>
            <p><a href="Path.html">Path</a> to the compiled asset metadata file.  If the
            file exists, will use compiled mode using the metadata in the file.  If the
            file does not exist, will use non-compiled mode, but will write the
            metadata to the file if compile_assets is called.</p>
            </td></tr><tr><td class='label'>:public </td><td>
            <p><a href="Path.html">Path</a> to your public folder, in which compiled files
            are placed (default: &#39;public&#39;).  Relative paths will be considered
            relative to the application&#39;s :root option.</p>
            </td></tr><tr><td class='label'>:sri </td><td>
            <p>Enables subresource integrity when setting up references to compiled
            assets. The value should be :sha256, :sha384, or :sha512 depending on which
            hash algorithm you want to use.  This changes the hash algorithm that <a
            href="../../Roda.html">Roda</a> will use when naming compiled asset files.
            The default is :sha256, you can use nil to disable subresource integrity.</p>
            </td></tr></tbody></table>
          </div>
          <div id='method-list'>
            <h2>Methods</h2>
            <h3>Public Class</h3>
            <ol>
              <li><a href="#method-c-configure">configure</a></li>
              <li><a href="#method-c-load_dependencies">load_dependencies</a></li>
            </ol>
          </div>
          <div id='context'>
          </div>
          <div id='class-list'>
            <h2>Classes and Modules</h2>
            <ol>
              <li><a href="Assets/ClassMethods.html">Roda::RodaPlugins::Assets::ClassMethods</a></li>
              <li><a href="Assets/InstanceMethods.html">Roda::RodaPlugins::Assets::InstanceMethods</a></li>
              <li><a href="Assets/RequestClassMethods.html">Roda::RodaPlugins::Assets::RequestClassMethods</a></li>
              <li><a href="Assets/RequestMethods.html">Roda::RodaPlugins::Assets::RequestMethods</a></li>
            </ol>
          </div>
          <div id='section'>
            <div id='constants-list'>
              <h2>Constants</h2>
              <div class='name-list'>
                <table summary='Constants'>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>CompressorNotFound</td>
                    <td>=</td>
                    <td class='context-item-value'>Class.new(RodaError)</td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'>
                      
                      <p>Internal exception raised when a compressor cannot be found</p>
                    </td>
                  </tr>
                  <tr class='top-aligned-row context-row'>
                    <td class='context-item-name'>DEFAULTS</td>
                    <td>=</td>
                    <td class='context-item-value'>
                      {
                      :compiled_name    => 'app'.freeze,
                      :js_dir           => 'js'.freeze,
                      :css_dir          => 'css'.freeze,
                      :prefix           => 'assets'.freeze,
                      :concat_only      => false,
                      :compiled         => false,
                      :add_suffix       => false,
                      :group_subdirs    => true,
                      :compiled_css_dir => nil,
                      :compiled_js_dir  => nil,
                      :sri              => :sha256
                      }.freeze
                    </td>
                    <td>&nbsp;</td>
                    <td class='context-item-desc'></td>
                  </tr>
                </table>
              </div>
            </div>
            <div id='methods'>
              <h2>Public Class methods</h2>
              <div class='method public-class' id='method-method-c-configure'>
                <a name='method-c-configure'></a>
                <div class='synopsis'>
                  <span class='name'>configure</span>
                  <span class='arguments'>(app, opts = {})</span>
                </div>
                <div class='description'>
                  
                  <p>Setup the options for the plugin.  See the <a href="Assets.html">Assets</a>
                  module RDoc for a description of the supported options.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-configure-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-configure-source'><span class="ruby-comment"># File lib/roda/plugins/assets.rb, line 324</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">configure</span>(<span class="ruby-identifier">app</span>, <span class="ruby-identifier">opts</span> = {})&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">app</span>.<span class="ruby-identifier">assets_opts</span>&#x000A;    <span class="ruby-identifier">prev_opts</span> = <span class="ruby-identifier">app</span>.<span class="ruby-identifier">assets_opts</span>[<span class="ruby-value">:orig_opts</span>]&#x000A;    <span class="ruby-identifier">orig_opts</span> = <span class="ruby-identifier">app</span>.<span class="ruby-identifier">assets_opts</span>[<span class="ruby-value">:orig_opts</span>].<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>)&#x000A;    [<span class="ruby-value">:headers</span>, <span class="ruby-value">:css_headers</span>, <span class="ruby-value">:js_headers</span>, <span class="ruby-value">:css_opts</span>, <span class="ruby-value">:js_opts</span>, <span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span>&#x000A;      <span class="ruby-keyword">if</span> <span class="ruby-identifier">prev_opts</span>[<span class="ruby-identifier">s</span>]&#x000A;        <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-identifier">s</span>]&#x000A;          <span class="ruby-identifier">orig_opts</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">prev_opts</span>[<span class="ruby-identifier">s</span>].<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-identifier">s</span>])&#x000A;        <span class="ruby-keyword">else</span>&#x000A;          <span class="ruby-identifier">orig_opts</span>[<span class="ruby-identifier">s</span>] = <span class="ruby-identifier">prev_opts</span>[<span class="ruby-identifier">s</span>].<span class="ruby-identifier">dup</span>&#x000A;        <span class="ruby-keyword">end</span>&#x000A;      <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-keyword">end</span>&#x000A;    <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:assets</span>] = <span class="ruby-identifier">orig_opts</span>.<span class="ruby-identifier">dup</span>&#x000A;    <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:assets</span>][<span class="ruby-value">:orig_opts</span>] = <span class="ruby-identifier">orig_opts</span>&#x000A;  <span class="ruby-keyword">else</span>&#x000A;    <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:assets</span>] = <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">dup</span>&#x000A;    <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:assets</span>][<span class="ruby-value">:orig_opts</span>] = <span class="ruby-identifier">opts</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">opts</span> = <span class="ruby-identifier">app</span>.<span class="ruby-identifier">opts</span>[<span class="ruby-value">:assets</span>]&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:path</span>] = <span class="ruby-identifier">app</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:path</span>]<span class="ruby-operator">||</span><span class="ruby-string">&quot;assets&quot;</span>).<span class="ruby-identifier">freeze</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:public</span>] = <span class="ruby-identifier">app</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:public</span>]<span class="ruby-operator">||</span><span class="ruby-string">&quot;public&quot;</span>).<span class="ruby-identifier">freeze</span>&#x000A;&#x000A;  <span class="ruby-comment"># Combine multiple values into a path, ignoring trailing slashes</span>&#x000A;  <span class="ruby-identifier">j</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-operator">*</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">v</span>).&#x000A;      <span class="ruby-identifier">reject</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">to_s</span>.<span class="ruby-identifier">empty?</span>}.&#x000A;      <span class="ruby-identifier">map</span>{<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">&#39;/&#39;</span>)}.&#x000A;      <span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;/&#39;</span>).<span class="ruby-identifier">freeze</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># Same as j, but add a trailing slash if not empty</span>&#x000A;  <span class="ruby-identifier">sj</span> = <span class="ruby-identifier">lambda</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-operator">*</span><span class="ruby-identifier">v</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">s</span> = <span class="ruby-identifier">j</span>.<span class="ruby-identifier">call</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">v</span>)&#x000A;    <span class="ruby-identifier">s</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">s</span> <span class="ruby-operator">:</span> (<span class="ruby-identifier">s</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;/&#39;</span>).<span class="ruby-identifier">freeze</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-value">:precompiled</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">opts</span>[<span class="ruby-value">:compiled</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">::</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">exist?</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:precompiled</span>])&#x000A;    <span class="ruby-identifier">require</span> <span class="ruby-string">&#39;json&#39;</span>&#x000A;    <span class="ruby-identifier">opts</span>[<span class="ruby-value">:compiled</span>] = <span class="ruby-operator">::</span><span class="ruby-constant">JSON</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-operator">::</span><span class="ruby-constant">File</span>.<span class="ruby-identifier">read</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:precompiled</span>]))&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-constant">DEFAULTS</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">opts</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">v</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">k</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  [&#x000A;   [<span class="ruby-value">:compiled_path</span>, <span class="ruby-value">:prefix</span>],&#x000A;   [<span class="ruby-value">:js_route</span>, <span class="ruby-value">:js_dir</span>],&#x000A;   [<span class="ruby-value">:css_route</span>, <span class="ruby-value">:css_dir</span>],&#x000A;   [<span class="ruby-value">:compiled_js_route</span>, <span class="ruby-value">:compiled_js_dir</span>],&#x000A;   [<span class="ruby-value">:compiled_css_route</span>, <span class="ruby-value">:compiled_css_dir</span>]&#x000A;  ].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">k</span>, <span class="ruby-identifier">v</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">opts</span>[<span class="ruby-identifier">k</span>]  = <span class="ruby-identifier">opts</span>[<span class="ruby-identifier">v</span>] <span class="ruby-keyword">unless</span> <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">has_key?</span>(<span class="ruby-identifier">k</span>)&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  [<span class="ruby-value">:css_headers</span>, <span class="ruby-value">:js_headers</span>, <span class="ruby-value">:css_opts</span>, <span class="ruby-value">:js_opts</span>, <span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">opts</span>[<span class="ruby-identifier">s</span>] <span class="ruby-operator">||=</span> {} &#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-keyword">if</span> <span class="ruby-identifier">headers</span> = <span class="ruby-identifier">opts</span>[<span class="ruby-value">:headers</span>]&#x000A;    <span class="ruby-identifier">opts</span>[<span class="ruby-value">:css_headers</span>] = <span class="ruby-identifier">headers</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:css_headers</span>])&#x000A;    <span class="ruby-identifier">opts</span>[<span class="ruby-value">:js_headers</span>]  = <span class="ruby-identifier">headers</span>.<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">opts</span>[<span class="ruby-value">:js_headers</span>])&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:css_headers</span>][<span class="ruby-string">&#39;Content-Type&#39;</span>] <span class="ruby-operator">||=</span> <span class="ruby-string">&quot;text/css; charset=UTF-8&quot;</span>.<span class="ruby-identifier">freeze</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:js_headers</span>][<span class="ruby-string">&#39;Content-Type&#39;</span>]  <span class="ruby-operator">||=</span> <span class="ruby-string">&quot;application/javascript; charset=UTF-8&quot;</span>.<span class="ruby-identifier">freeze</span>&#x000A;&#x000A;  [<span class="ruby-value">:css_headers</span>, <span class="ruby-value">:js_headers</span>, <span class="ruby-value">:css_opts</span>, <span class="ruby-value">:js_opts</span>, <span class="ruby-value">:dependencies</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">opts</span>[<span class="ruby-identifier">s</span>].<span class="ruby-identifier">freeze</span>&#x000A;  <span class="ruby-keyword">end</span>&#x000A;  [<span class="ruby-value">:headers</span>, <span class="ruby-value">:css</span>, <span class="ruby-value">:js</span>].<span class="ruby-identifier">each</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span>&#x000A;    <span class="ruby-identifier">opts</span>[<span class="ruby-identifier">s</span>].<span class="ruby-identifier">freeze</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">opts</span>[<span class="ruby-identifier">s</span>]&#x000A;  <span class="ruby-keyword">end</span>&#x000A;&#x000A;  <span class="ruby-comment"># Used for reading/writing files</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:js_path</span>]           = <span class="ruby-identifier">sj</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:path</span>, <span class="ruby-value">:js_dir</span>)&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:css_path</span>]          = <span class="ruby-identifier">sj</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:path</span>, <span class="ruby-value">:css_dir</span>)&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:compiled_js_path</span>]  = <span class="ruby-identifier">j</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:public</span>, <span class="ruby-value">:compiled_path</span>, <span class="ruby-value">:compiled_js_dir</span>, <span class="ruby-value">:compiled_name</span>)&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:compiled_css_path</span>] = <span class="ruby-identifier">j</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:public</span>, <span class="ruby-value">:compiled_path</span>, <span class="ruby-value">:compiled_css_dir</span>, <span class="ruby-value">:compiled_name</span>)&#x000A;&#x000A;  <span class="ruby-comment"># Used for URLs/routes</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:js_prefix</span>]           = <span class="ruby-identifier">sj</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:prefix</span>, <span class="ruby-value">:js_route</span>)&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:css_prefix</span>]          = <span class="ruby-identifier">sj</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:prefix</span>, <span class="ruby-value">:css_route</span>)&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:compiled_js_prefix</span>]  = <span class="ruby-identifier">j</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:prefix</span>, <span class="ruby-value">:compiled_js_route</span>, <span class="ruby-value">:compiled_name</span>)&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:compiled_css_prefix</span>] = <span class="ruby-identifier">j</span>.<span class="ruby-identifier">call</span>(<span class="ruby-value">:prefix</span>, <span class="ruby-value">:compiled_css_route</span>, <span class="ruby-value">:compiled_name</span>)&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:js_suffix</span>]           = (<span class="ruby-identifier">opts</span>[<span class="ruby-value">:add_suffix</span>] <span class="ruby-operator">?</span> <span class="ruby-string">&#39;.js&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">freeze</span>&#x000A;  <span class="ruby-identifier">opts</span>[<span class="ruby-value">:css_suffix</span>]          = (<span class="ruby-identifier">opts</span>[<span class="ruby-value">:add_suffix</span>] <span class="ruby-operator">?</span> <span class="ruby-string">&#39;.css&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">freeze</span>&#x000A;&#x000A;  <span class="ruby-identifier">opts</span>.<span class="ruby-identifier">freeze</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
              <div class='method public-class' id='method-method-c-load_dependencies'>
                <a name='method-c-load_dependencies'></a>
                <div class='synopsis'>
                  <span class='name'>load_dependencies</span>
                  <span class='arguments'>(app, _opts = nil)</span>
                </div>
                <div class='description'>
                  
                  <p>Load the render, caching, and h plugins, since the assets plugin depends on
                  them.</p>
                </div>
                <div class='source'>
                  <a class='source-toggle' href='#' onclick="toggleCode('method-c-load_dependencies-source'); return false">
                    [show source]
                  </a>
                  <pre id='method-c-load_dependencies-source'><span class="ruby-comment"># File lib/roda/plugins/assets.rb, line 316</span>&#x000A;<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">load_dependencies</span>(<span class="ruby-identifier">app</span>, <span class="ruby-identifier">_opts</span> = <span class="ruby-keyword">nil</span>)&#x000A;  <span class="ruby-identifier">app</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:render</span>&#x000A;  <span class="ruby-identifier">app</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:caching</span>&#x000A;  <span class="ruby-identifier">app</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:h</span>&#x000A;<span class="ruby-keyword">end</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id='footer-push'></div>
    </div>
    <div id='footer'>
      <a href="https://github.com/rdoc/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
    </div>
  </body>
</html>
