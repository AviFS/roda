<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang='en'>
<head>
<title>Roda::RodaPlugins::StaticRouting</title>
<meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
<link href='../../../css/style.css' media='screen' rel='stylesheet' type='text/css'>
<script type='text/javascript'>
  function popupCode(url) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }
  
  function toggleCode(id) {
    var code = document.getElementById(id)
  
    code.style.display = code.style.display != 'block' ? 'block' : 'none'
    return true
  }
  
  // Make codeblocks hidden by default
  document.writeln('<' + 'style type="text/css">.method .source pre { display: none }<\/style>')
</script>
</head>
<body class='page'>
<div class='class' id='wrapper'>
<div class='header'>
<h1 class='name'><span class='type'>module</span>
Roda::RodaPlugins::StaticRouting
</h1>
<ol class='paths'>
<li>
<a href="../../../files/lib/roda/plugins/static_routing_rb.html">lib/roda/plugins/static_routing.rb</a>
</li>
</ol>
</div>
<div id='content'>
<div id='text'>
<div id='description'>
<p>The static_routing plugin adds static_* routing class methods for handling static routes (i.e. routes with static paths, no nesting or placeholders).  These routes are processed before the normal routing tree and designed for maximum performance.  This can be substantially faster than Roda’s normal tree based routing if you have large numbers of static routes, about 3-4x for 100-10000 static routes.  Example:</p>

<pre class="ruby"><span class="ruby-identifier">plugin</span> <span class="ruby-value">:static_routing</span>

<span class="ruby-identifier">static_route</span> <span class="ruby-string">&#39;/foo&#39;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-ivar">@var</span> = <span class="ruby-value">:foo</span>

  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">get</span> <span class="ruby-keyword">do</span>
    <span class="ruby-string">&#39;Not actually reached&#39;</span>
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">r</span>.<span class="ruby-identifier">post</span>{<span class="ruby-string">&#39;static POST /#{@var}&#39;</span>}
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">static_get</span> <span class="ruby-string">&#39;/foo&#39;</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-string">&#39;static GET /foo&#39;</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">route</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">r</span><span class="ruby-operator">|</span>
  <span class="ruby-string">&#39;Not a static route&#39;</span>
<span class="ruby-keyword">end</span>
</pre>

<p>A few things to note in the above example.  First, unlike most other routing methods in <a href="../../Roda.html"><code>Roda</code></a>, these take the full path of the request, and only match if r.path_info matches exactly.  This is why you need to include the leading slash in the path argument.</p>

<p>Second, the static_* routing methods only take a single string argument for the path, they do not accept other options, and do not handle placeholders in strings.  For any routes needing placeholders, you should use Roda’s routing tree.</p>

<p>There are separate static_* methods for each type of request method, and these request method specific routes are tried first.  There is also a static_route method that will match regardless of the request method, if there is no matching request methods specific route.  This is why the static_get method call takes precedence over the static_route method call for /foo. As shown above, you can use Roda’s routing tree methods inside the static_route block to have shared behavior for different request methods, while still handling the request methods differently.</p>
</div>
<div id='method-list'>
<h2>Methods</h2>
<h3>Public Class</h3>
<ol>
<li><a href="#method-c-load_dependencies">load_dependencies</a></li>
</ol>
</div>
<div id='context'>
</div>
<div id='class-list'>
<h2>Classes and Modules</h2>
<ol>
<li><a href="StaticRouting/ClassMethods.html">Roda::RodaPlugins::StaticRouting::ClassMethods</a></li>
<li><a href="StaticRouting/InstanceMethods.html">Roda::RodaPlugins::StaticRouting::InstanceMethods</a></li>
</ol>
</div>
<div id='section'>
<div id='methods'>
<h2>Public Class methods</h2>
<div class='method public-class' id='method-method-c-load_dependencies'>
<a name='method-c-load_dependencies'></a>
<div class='synopsis'>
<span class='name'>load_dependencies</span><span class='arguments'>(app)</span>

</div>
<div class='description'>

</div>
<div class='source'>
<a class='source-toggle' href='#' onclick='toggleCode(&#39;method-c-load_dependencies-source&#39;); return false'>
[show source]
</a>
<pre id='method-c-load_dependencies-source'>   <span class="ruby-comment"># File lib/roda/plugins/static_routing.rb</span>
<span class="line-num">52</span> <span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">load_dependencies</span>(<span class="ruby-identifier">app</span>)
<span class="line-num">53</span>   <span class="ruby-identifier">app</span>.<span class="ruby-identifier">plugin</span> <span class="ruby-value">:hash_routes</span>
<span class="line-num">54</span> <span class="ruby-keyword">end</span></pre>
</div>
</div>
</div>
</div>

</div>
</div>

<div id='footer-push'></div>
</div>
<div id='footer'>
<a href="https://github.com/jeremyevans/hanna-nouveau"><strong>Hanna Nouveau</strong> RDoc template</a>
</div>
</body>
</html>
